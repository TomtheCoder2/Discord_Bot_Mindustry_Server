"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Schematic = void 0;
var tslib_1 = require("tslib");
var renderer = tslib_1.__importStar(require("./renderer"));
var mindustry_1 = require("../mindustry");
var io_1 = require("./io");
var canvas_1 = require("canvas");
var util_1 = require("./renderer/util");
var _a = mindustry_1.Blocks.distribution, Conveyor = _a.Conveyor, PlastaniumConveyor = _a.PlastaniumConveyor, Conduit = mindustry_1.Blocks.liquid.Conduit, PowerGenerator = mindustry_1.Blocks.power.PowerGenerator;
/**
 * A simple representation for a mindustry schematic
 */
var Schematic = /** @class */ (function () {
    function Schematic(properties) {
        var _a;
        // this prevents the user for assignin any property through the constructor
        var version;
        (this.tiles = properties.tiles, this.height = properties.height, this.tags = properties.tags, this.width = properties.width, this.base64 = properties.base64, _a = properties.version, version = _a === void 0 ? 'v6' : _a);
        this.version = version;
        if (!this.description) {
            this.description = '';
        }
    }
    Schematic.decode = function (data) {
        return io_1.SchematicIO.decode(data);
    };
    Schematic.encode = function (schematic) {
        return schematic.encode();
    };
    Object.defineProperty(Schematic.prototype, "name", {
        /**
         * The name of this schematic
         *
         * Shorhand for `tags.get('name')`
         */
        get: function () {
            return this.tags.get('name');
        },
        set: function (value) {
            this.tags.set('name', value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Schematic.prototype, "description", {
        /**
         * The description of this schematic
         *
         * Shorhand for `tags.get('name')`
         */
        get: function () {
            var _a;
            return (_a = this.tags.get('description')) !== null && _a !== void 0 ? _a : '';
        },
        set: function (value) {
            this.tags.set('description', value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Schematic.prototype, "powerProduction", {
        /**
         * The amount of power this schematic can produce
         *
         * This is a separated measurement that does not interfere with `powerConsumption`
         *
         * This measurement may vary if there is an `OverdriveProjector` or an `OverdriveDome` contained in this schematic
         */
        get: function () {
            var e_1, _a;
            var result = 0;
            try {
                for (var _b = tslib_1.__values(this.tiles), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var tile = _c.value;
                    result +=
                        tile.block instanceof PowerGenerator ? tile.block.powerGeneration : 0;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return result;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Schematic.prototype, "powerConsumption", {
        /**
         * The amount of power this schematic consumes to work properly
         *
         * This is a separated measurement that does not interfere with `powerConsumption`
         *
         * This measurement may vary if there is an `OverdriveProjector` or an `OverdriveDome` contained in this schematic
         */
        get: function () {
            var e_2, _a;
            var result = 0;
            try {
                for (var _b = tslib_1.__values(this.tiles), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var tile = _c.value;
                    result += tile.block.powerConsumption;
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return result;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Schematic.prototype, "powerBalance", {
        /**
         * The overall power balance of this schematic
         */
        get: function () {
            return this.powerProduction - this.powerConsumption;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Schematic.prototype, "requirements", {
        /**
         * The items needed to build this schematic
         */
        get: function () {
            var e_3, _a;
            var _b;
            var requirements = {};
            try {
                for (var _c = tslib_1.__values(this.tiles), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var tile = _d.value;
                    var block = tile.block;
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    var req = block.requirements;
                    for (var key in req) {
                        // console.log(block.name, req)
                        var item = key;
                        var cost = req[item];
                        var currentCost = (_b = requirements[item]) !== null && _b !== void 0 ? _b : 0;
                        requirements[item] = currentCost + cost;
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_3) throw e_3.error; }
            }
            return requirements;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Converts this schematic to a base 64 string
     */
    Schematic.prototype.encode = function () {
        if (!this.base64)
            throw new Error('by now, the schematic needs to be generated from a SchematicDecoder');
        return io_1.SchematicIO.encodeTags(this);
    };
    /**
     * Creates an image that represents this schematic's preview
     */
    Schematic.prototype.toImageBuffer = function (options) {
        var _a, _b, _c, _d, _e, _f, _g;
        var _h, _j;
        if (options === void 0) { options = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var canvas, size, mappedTiles, _k, _l, tile, block, e_4_1, background, bcontext, border, scale, width, height;
            var e_4, _m;
            return tslib_1.__generator(this, function (_o) {
                switch (_o.label) {
                    case 0:
                        // default options
                        (_a = options.background) !== null && _a !== void 0 ? _a : (options.background = true);
                        (_b = options.bridges) !== null && _b !== void 0 ? _b : (options.bridges = { opacity: 0.7, render: true });
                        (_c = (_h = options.bridges).render) !== null && _c !== void 0 ? _c : (_h.render = true);
                        (_d = options.conduits) !== null && _d !== void 0 ? _d : (options.conduits = { render: true });
                        (_e = options.conveyors) !== null && _e !== void 0 ? _e : (options.conveyors = { render: true });
                        (_f = options.phaseBridges) !== null && _f !== void 0 ? _f : (options.phaseBridges = { opacity: 1, render: true });
                        (_g = (_j = options.phaseBridges).render) !== null && _g !== void 0 ? _g : (_j.render = true);
                        canvas = canvas_1.createCanvas(this.width * 32, this.height * 32);
                        size = Math.max(this.width, this.height) * 32;
                        if (options.background)
                            size += 64;
                        if (options.size) {
                            ;
                            (size = options.size);
                        }
                        else if (options.maxSize) {
                            size = Math.min(options.maxSize, size);
                        }
                        mappedTiles = util_1.mapTiles(this);
                        _o.label = 1;
                    case 1:
                        _o.trys.push([1, 6, 7, 8]);
                        _k = tslib_1.__values(this.tiles), _l = _k.next();
                        _o.label = 2;
                    case 2:
                        if (!!_l.done) return [3 /*break*/, 5];
                        tile = _l.value;
                        block = tile.block;
                        if (block instanceof Conveyor ||
                            block instanceof PlastaniumConveyor ||
                            block instanceof Conduit)
                            return [3 /*break*/, 4];
                        return [4 /*yield*/, block.draw(tile, canvas)];
                    case 3:
                        _o.sent();
                        _o.label = 4;
                    case 4:
                        _l = _k.next();
                        return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 8];
                    case 6:
                        e_4_1 = _o.sent();
                        e_4 = { error: e_4_1 };
                        return [3 /*break*/, 8];
                    case 7:
                        try {
                            if (_l && !_l.done && (_m = _k.return)) _m.call(_k);
                        }
                        finally { if (e_4) throw e_4.error; }
                        return [7 /*endfinally*/];
                    case 8:
                        if (!(options.conveyors.render || options.conduits.render)) return [3 /*break*/, 10];
                        return [4 /*yield*/, renderer.drawChained(this, canvas, mappedTiles, options)];
                    case 9:
                        _o.sent();
                        _o.label = 10;
                    case 10:
                        if (!options.bridges.render) return [3 /*break*/, 12];
                        return [4 /*yield*/, renderer.drawBridges(this, canvas, mappedTiles, options)];
                    case 11:
                        _o.sent();
                        _o.label = 12;
                    case 12:
                        background = canvas_1.createCanvas(size, size);
                        if (!options.background) return [3 /*break*/, 14];
                        return [4 /*yield*/, renderer.drawBackground(background, size)];
                    case 13:
                        _o.sent();
                        _o.label = 14;
                    case 14:
                        bcontext = background.getContext('2d');
                        border = options.background ? 64 : 0;
                        scale = (size - border) / Math.max(canvas.height, canvas.width);
                        width = canvas.width * scale, height = canvas.height * scale;
                        bcontext.drawImage(canvas, (size - width) / 2, (size - height) / 2, width, height);
                        return [2 /*return*/, background.toBuffer()];
                }
            });
        });
    };
    return Schematic;
}());
exports.Schematic = Schematic;
//# sourceMappingURL=schematic.js.map