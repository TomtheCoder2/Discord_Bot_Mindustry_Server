"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SchematicDecoder = exports.SchematicIO = void 0;
var tslib_1 = require("tslib");
var mindustry_1 = require("../mindustry");
var streamed_data_1 = require("../streamed_data");
var item_1 = require("../mindustry/item");
var pako_1 = tslib_1.__importDefault(require("pako"));
var arc_1 = require("../arc");
var schematic_1 = require("./schematic");
var tile_1 = require("./tile");
var _a = mindustry_1.Blocks.distribution, Sorter = _a.Sorter, InvertedSorter = _a.InvertedSorter, MassDriver = _a.MassDriver, ItemBridge = _a.ItemBridge, PhaseConveyor = _a.PhaseConveyor, Unloader = mindustry_1.Blocks.storage.Unloader, _b = mindustry_1.Blocks.sandbox, ItemSource = _b.ItemSource, LiquidSource = _b.LiquidSource, LightBlock = _b.LightBlock, AirBlock = mindustry_1.Blocks.environment.AirBlock;
var SchematicIO = /** @class */ (function () {
    function SchematicIO() {
    }
    SchematicIO.isValid = function (data, consumeData) {
        var e_1, _a;
        if (consumeData === void 0) { consumeData = false; }
        var header = SchematicIO.header;
        if (consumeData) {
            try {
                for (var header_1 = tslib_1.__values(header), header_1_1 = header_1.next(); !header_1_1.done; header_1_1 = header_1.next()) {
                    var char = header_1_1.value;
                    if (char !== data.getChar())
                        return false;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (header_1_1 && !header_1_1.done && (_a = header_1.return)) _a.call(header_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return true;
        }
        for (var i = 0; i < header.length; i++) {
            if (header[i] !== String.fromCodePoint(data.data.getUint8(i))) {
                return false;
            }
        }
        return true;
    };
    SchematicIO.compressedData = function (data) {
        var bytes = pako_1.default.inflate(new Uint8Array(data.buffer).subarray(data.offset));
        return new streamed_data_1.StreamedDataReader(bytes.buffer);
    };
    SchematicIO.tags = function (cData) {
        var tags = new Map();
        var numberOfTags = cData.getInt8();
        for (var i = 0; i < numberOfTags; i++) {
            var name_1 = cData.getString();
            var value = cData.getString();
            tags.set(name_1, value);
        }
        return tags;
    };
    SchematicIO.blocks = function (cData) {
        var length = cData.getInt8();
        var blocks = [];
        for (var i = 0; i < length; i++) {
            var block = mindustry_1.Block.fromCode(cData.getString());
            blocks.push(block);
        }
        return blocks;
    };
    SchematicIO.mapConfig = function (block, value, position) {
        // by now, lets just throw the config info away
        if (block instanceof Sorter ||
            block instanceof InvertedSorter ||
            block instanceof Unloader ||
            block instanceof ItemSource) {
            return item_1.Item.fromCode(value);
        }
        if (block instanceof LiquidSource) {
            return mindustry_1.Liquid.fromCode(value);
        }
        if (block instanceof MassDriver ||
            block instanceof ItemBridge ||
            block instanceof PhaseConveyor) {
            return arc_1.Point2.unpack(value).sub(arc_1.Point2.x(position), arc_1.Point2.y(position));
        }
        if (block instanceof LightBlock)
            return value;
        return null;
    };
    SchematicIO.readConfigObject = function (cData) {
        var type = cData.getInt8();
        switch (type) {
            case 0:
                return null;
            case 1:
                return cData.getInt32();
            case 2:
                return cData.getBigInt64();
            case 3:
                return cData.getFloat32();
            case 4: {
                var exists = cData.getInt8();
                if (exists !== 0) {
                    try {
                        return cData.getString();
                    }
                    catch (e) {
                        if (e instanceof streamed_data_1.StringParsingError) {
                            return e.parsedText;
                        }
                        throw e;
                    }
                }
                return null;
            }
            case 5: {
                var value = cData.getInt8();
                var code = cData.getInt16();
                switch (value) {
                    case 0:
                        return item_1.Item.fromCode(code);
                    case 4:
                        return mindustry_1.Liquid.fromCode(code);
                    default:
                        // consume the short to avoid errors
                        cData.getInt16();
                        return;
                }
            }
            // return Vars.content.getByID(
            //   (ContentType[
            //     // eslint-disable-next-line @typescript-eslint/no-explicit-any
            //     ContentType[cData.getInt8()] as any
            //   ] as unknown) as ContentType,
            //   cData.getInt16()
            // )
            // original code:
            // return content.getByID(ContentType.all[read.b()], read.s());
            case 6: {
                var length_1 = cData.getInt16();
                var arr = [];
                for (var i = 0; i < length_1; i++) {
                    arr.push(cData.getInt32());
                }
                return arr;
            }
            // original code
            // short length = read.s(); IntSeq arr = new IntSeq(); for (int i = 0; i < length; i++) arr.add(read.i()); return arr;
            case 7:
                return new arc_1.Point2(cData.getInt32(), cData.getInt32());
            case 8: {
                var len = cData.getInt8();
                var out = [];
                for (var i = 0; i < len; i++) {
                    out.push(arc_1.Point2.unpack(cData.getInt32()));
                }
                // byte len = read.b(); Point2[] out = new Point2[len]; for (int i = 0; i < len; i++) out[i] = Point2.unpack(read.i());
                return out;
            }
            // TODO: somehow implement java code bellow
            case 9:
                //  by now just ignore the config data
                cData.getInt8();
                cData.getInt16();
                break;
            // return TechTree.getNotNull(content.getByID(ContentType.all[read.b()], read.s()));
            case 10:
                return cData.getBool();
            // return read.bool();
            case 11:
                return cData.getFloat64();
            // return read.d();
            case 12:
                cData.getInt32();
                return;
            // return world.build(read.i());
            case 13:
                cData.getInt16();
                return;
            // return LAccess.all[read.s()];
            case 14: {
                var blen = cData.getInt32();
                var bytes = [];
                for (var i = 0; i < blen; i++)
                    bytes.push(cData.getInt8());
                return bytes;
            }
            // int blen = read.i(); byte[] bytes = new byte[blen]; read.b(bytes); return bytes;
            case 15:
                return mindustry_1.UnitCommand[cData.getInt8()];
            default:
                throw new Error('Unknown object type: ' + type);
            // throw new IllegalArgumentException('Unknown object type: ' + type)
        }
    };
    SchematicIO.tiles = function (cData, blocks, version) {
        var total = cData.getInt32();
        var tiles = [];
        for (var i = 0; i < total; i++) {
            var block = blocks[cData.getInt8()];
            var position = cData.getInt32();
            var config = version === 0
                ? this.mapConfig(block, cData.getInt32(), position)
                : this.readConfigObject(cData);
            var rotation = cData.getInt8();
            if (block instanceof AirBlock)
                continue;
            tiles.push(new tile_1.SchematicTile(block, arc_1.Point2.x(position), arc_1.Point2.y(position), config, rotation));
        }
        return tiles;
    };
    SchematicIO.schematicSize = function (cData) {
        var width = cData.getInt16(), height = cData.getInt16();
        return { width: width, height: height };
    };
    /**
     * Parses the data and returns a schematic
     *  @param encoded The encoded schematic data
     */
    SchematicIO.decode = function (encoded) {
        var decoded = typeof encoded === 'string'
            ? Buffer.from(encoded.trim(), 'base64')
            : encoded;
        var arr = new Uint8Array(decoded);
        var data = new streamed_data_1.StreamedDataReader(arr.buffer);
        if (!this.isValid(data, true)) {
            throw new Error('Parsing error: this is not a valid schematic');
        }
        var version = data.getInt8();
        var cData = this.compressedData(data);
        var _a = this.schematicSize(cData), width = _a.width, height = _a.height;
        var tags = this.tags(cData);
        var blocks = this.blocks(cData);
        var tiles = this.tiles(cData, blocks, version);
        var base64 = typeof encoded === 'string' ? encoded : encoded.toString('base64');
        return new schematic_1.Schematic({
            height: height,
            tags: tags,
            tiles: tiles,
            width: width,
            base64: base64,
            version: version === 0 ? 'v5' : 'v6',
        });
    };
    /** Takes a decoded schematic and saves its new tags
     * @param schematic A decoded schematic in wich the tags were modified
     */
    SchematicIO.encodeTags = function (schematic) {
        if (!schematic.base64)
            throw new Error('cannot save the tags of a non parsed schematic');
        var decoded = Buffer.from(schematic.base64, 'base64');
        var arr = new Uint8Array(decoded);
        var data = new streamed_data_1.StreamedDataReader(arr.buffer);
        // read header
        this.isValid(data, true);
        // read version
        data.getInt8();
        var cData = this.compressedData(data);
        // read size
        this.schematicSize(cData);
        var tagsStart = cData.offset;
        // read old tags
        this.tags(cData);
        var tagsEnd = cData.offset;
        var newTags = schematic.tags;
        var tagSafeSize = 0;
        newTags.forEach(function (val, key) {
            tagSafeSize += val.length + key.length;
        });
        var writer = new streamed_data_1.StreamedDataWriter(new ArrayBuffer(tagSafeSize * 2));
        writer.setInt8(newTags.size);
        newTags.forEach(function (value, key) {
            writer.setString(key);
            writer.setString(value !== null && value !== void 0 ? value : '');
        });
        var newBuffer = writer.buffer.slice(0, writer.offset);
        var result = concatBytes(new Uint8Array(cData.buffer).subarray(0, tagsStart), new Uint8Array(newBuffer).subarray(0, writer.offset), new Uint8Array(cData.buffer).subarray(tagsEnd));
        var bytes = pako_1.default.deflate(result);
        var resultWriter = new streamed_data_1.StreamedDataWriter(new ArrayBuffer(bytes.byteLength + 5));
        resultWriter.setChar('m');
        resultWriter.setChar('s');
        resultWriter.setChar('c');
        resultWriter.setChar('h');
        resultWriter.setInt8(schematic.version === 'v5' ? 0 : 1);
        for (var i = 0; i < bytes.byteLength; i++) {
            resultWriter.setUint8(bytes[i]);
        }
        return Buffer.from(resultWriter.buffer.slice(0, resultWriter.offset)).toString('base64');
    };
    SchematicIO.header = 'msch';
    SchematicIO.version = 1;
    return SchematicIO;
}());
exports.SchematicIO = SchematicIO;
/**
 * A simple way to decode schematics
 * @deprecated The use of this class is deprecated, use `Schematic.decode` instead
 */
var SchematicDecoder = /** @class */ (function (_super) {
    tslib_1.__extends(SchematicDecoder, _super);
    function SchematicDecoder(value) {
        var _this = _super.call(this) || this;
        _this.value = value;
        var decoded = Buffer.from(value.trim(), 'base64').toString('binary');
        var arr = new Uint8Array(decoded.length);
        for (var i = 0; i < decoded.length; i++) {
            var char = decoded.codePointAt(i);
            if (char === null || char === undefined)
                throw new Error('unknown character at: ' + i);
            arr[i] = char;
        }
        _this.data = new streamed_data_1.StreamedDataReader(arr.buffer);
        return _this;
    }
    /**
     * Parses the text and returns a schematic
     *
     * If called multiple times, the same `Schematic` instance will be returned
     *
     * @deprecated This class is deprecated use `Schematic.decode` instead
     */
    SchematicDecoder.prototype.decode = function () {
        if (this.schematic)
            return this.schematic;
        this.schematic = SchematicIO.decode(this.value);
        return this.schematic;
    };
    /**
     * @deprecated The use of this method is deprecated, use `Schematic.encode` instead
     */
    SchematicDecoder.prototype.encodeWithTags = function (schematic) {
        return SchematicIO.encodeTags(schematic);
    };
    return SchematicDecoder;
}(SchematicIO));
exports.SchematicDecoder = SchematicDecoder;
function concatBytes() {
    var e_2, _a, e_3, _b;
    var arrays = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        arrays[_i] = arguments[_i];
    }
    var totalLength = 0;
    try {
        for (var arrays_1 = tslib_1.__values(arrays), arrays_1_1 = arrays_1.next(); !arrays_1_1.done; arrays_1_1 = arrays_1.next()) {
            var arr = arrays_1_1.value;
            totalLength += arr.byteLength;
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (arrays_1_1 && !arrays_1_1.done && (_a = arrays_1.return)) _a.call(arrays_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    var result = new Uint8Array(totalLength);
    var currentOffset = 0;
    try {
        for (var arrays_2 = tslib_1.__values(arrays), arrays_2_1 = arrays_2.next(); !arrays_2_1.done; arrays_2_1 = arrays_2.next()) {
            var arr = arrays_2_1.value;
            result.set(arr, currentOffset);
            currentOffset += arr.length;
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (arrays_2_1 && !arrays_2_1.done && (_b = arrays_2.return)) _b.call(arrays_2);
        }
        finally { if (e_3) throw e_3.error; }
    }
    return result;
}
//# sourceMappingURL=io.js.map