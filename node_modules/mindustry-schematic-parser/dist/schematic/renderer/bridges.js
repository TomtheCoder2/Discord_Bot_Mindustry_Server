"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.drawBridges = void 0;
var tslib_1 = require("tslib");
var canvas_1 = require("canvas");
var util_1 = require("../../util");
var rotation_1 = require("./rotation");
var mindustry_1 = require("../../mindustry");
var _a = mindustry_1.Blocks.distribution, ItemBridge = _a.ItemBridge, PhaseConveyor = _a.PhaseConveyor, _b = mindustry_1.Blocks.liquid, BridgeConduit = _b.BridgeConduit, PhaseConduit = _b.PhaseConduit;
function drawBridges(schematic, canvas, mappedTiles, options) {
    var _a, _b, _c;
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var _d, _e, tile, block, category, config, targetPos, target, degrees, distance, bridge, arrow, context, tcanvas, tcontext, rotation, end, i, _f, x, y, offset, opacity, e_1_1;
        var e_1, _g;
        return tslib_1.__generator(this, function (_h) {
            switch (_h.label) {
                case 0:
                    _h.trys.push([0, 7, 8, 9]);
                    _d = tslib_1.__values(schematic.tiles), _e = _d.next();
                    _h.label = 1;
                case 1:
                    if (!!_e.done) return [3 /*break*/, 6];
                    tile = _e.value;
                    block = tile.block;
                    if (!(block instanceof ItemBridge || block instanceof BridgeConduit))
                        return [3 /*break*/, 5];
                    category = block instanceof ItemBridge ? 'distribution' : 'liquid';
                    config = tile.config;
                    if (!config)
                        return [3 /*break*/, 5];
                    targetPos = config.cpy().add(tile.x, tile.y);
                    target = (_a = mappedTiles[targetPos.x]) === null || _a === void 0 ? void 0 : _a[targetPos.y];
                    degrees = [0, -90, 180, 90];
                    distance = Math.abs(config.x === 0 ? config.y : config.x);
                    if ((target === null || target === void 0 ? void 0 : target.block.name) !== block.name)
                        return [3 /*break*/, 5];
                    return [4 /*yield*/, util_1.blockAsset(category, block.name + '-bridge')];
                case 2:
                    bridge = _h.sent();
                    return [4 /*yield*/, util_1.blockAsset(category, block.name + '-arrow')];
                case 3:
                    arrow = _h.sent();
                    context = canvas.getContext('2d');
                    tcanvas = canvas_1.createCanvas((distance + 1) * 32, 32);
                    tcontext = tcanvas.getContext('2d');
                    rotation = void 0;
                    if (config.x) {
                        rotation = config.x > 0 ? rotation_1.BlockRotation.right : rotation_1.BlockRotation.left;
                    }
                    else {
                        rotation = config.y > 0 ? rotation_1.BlockRotation.top : rotation_1.BlockRotation.bottom;
                    }
                    return [4 /*yield*/, util_1.blockAsset(category, block.name + '-end')];
                case 4:
                    end = _h.sent();
                    drawRotated(tcanvas, end, 0, 0, -90);
                    drawRotated(tcanvas, end, distance * 32, 0, 90);
                    for (i = 0; i < distance - 1; i++) {
                        tcontext.drawImage(bridge, (i + 1) * 32, 0);
                    }
                    _f = util_1.translatePos(tile, canvas), x = _f.x, y = _f.y;
                    offset = {
                        x: -16,
                        y: -16,
                    };
                    tcontext.drawImage(arrow, (tcanvas.width - arrow.width) / 2, 0);
                    context.save();
                    opacity = block instanceof PhaseConduit || block instanceof PhaseConveyor
                        ? (_b = options.phaseBridges) === null || _b === void 0 ? void 0 : _b.opacity
                        : (_c = options.bridges) === null || _c === void 0 ? void 0 : _c.opacity;
                    context.globalAlpha = opacity !== null && opacity !== void 0 ? opacity : 1;
                    drawRotated(canvas, tcanvas, x, y, degrees[rotation], offset.x, offset.y);
                    context.restore();
                    _h.label = 5;
                case 5:
                    _e = _d.next();
                    return [3 /*break*/, 1];
                case 6: return [3 /*break*/, 9];
                case 7:
                    e_1_1 = _h.sent();
                    e_1 = { error: e_1_1 };
                    return [3 /*break*/, 9];
                case 8:
                    try {
                        if (_e && !_e.done && (_g = _d.return)) _g.call(_d);
                    }
                    finally { if (e_1) throw e_1.error; }
                    return [7 /*endfinally*/];
                case 9: return [2 /*return*/];
            }
        });
    });
}
exports.drawBridges = drawBridges;
function drawRotated(canvas, image, x, y, degrees, offsetX, offsetY) {
    if (offsetX === void 0) { offsetX = -16; }
    if (offsetY === void 0) { offsetY = -16; }
    var context = canvas.getContext('2d');
    context.save();
    context.translate(x + 16, y + 16);
    context.rotate((degrees * Math.PI) / 180);
    context.translate(offsetX, offsetY);
    context.drawImage(image, 0, 0);
    context.restore();
}
//# sourceMappingURL=bridges.js.map