"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamedDataReader = void 0;
var errors_1 = require("./errors");
/**
 * Similar to a DataView, but it has an auto incrementing offset.
 * A mix of `DataView` and the `DataInputStream` java class
 */
var StreamedDataReader = /** @class */ (function () {
    function StreamedDataReader(buffer) {
        this.buffer = buffer;
        /**
         * Internal byte offset of this `StreamedDataView`
         */
        this.currentOffset = 0;
        this.data = new DataView(buffer);
    }
    Object.defineProperty(StreamedDataReader.prototype, "offset", {
        /**
         * The current byte offset of this `StreamedDataView`
         */
        get: function () {
            return this.currentOffset;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Reads the next 4 bytes as a 32-bit float value. There is
     * no alignment constraint; multi-byte values may be fetched from any offset.
     */
    StreamedDataReader.prototype.getFloat32 = function (littleEndian) {
        if (littleEndian === void 0) { littleEndian = false; }
        var value = this.data.getFloat32(this.currentOffset, littleEndian);
        this.currentOffset += 4;
        return value;
    };
    /**
     * Reads the next 8 bytes as a 64-bit float value. There is
     * no alignment constraint; multi-byte values may be fetched from any offset.
     */
    StreamedDataReader.prototype.getFloat64 = function (littleEndian) {
        if (littleEndian === void 0) { littleEndian = false; }
        var value = this.data.getFloat64(this.currentOffset, littleEndian);
        this.currentOffset += 8;
        return value;
    };
    /**
     * Reads the next byte as a 8-bit int. There is
     * no alignment constraint; multi-byte values may be fetched from any offset.
     */
    StreamedDataReader.prototype.getInt8 = function () {
        var value = this.data.getInt8(this.currentOffset);
        this.currentOffset++;
        return value;
    };
    /**
     * Reads the next 2 bytes as a 16-bit int. There is
     * no alignment constraint; multi-byte values may be fetched from any offset.
     */
    StreamedDataReader.prototype.getInt16 = function (littleEndian) {
        if (littleEndian === void 0) { littleEndian = false; }
        var value = this.data.getInt16(this.currentOffset, littleEndian);
        this.currentOffset += 2;
        return value;
    };
    /**
     * Reads the next 4 bytes as a 32-bit int. There is
     * no alignment constraint; multi-byte values may be fetched from any offset.
     */
    StreamedDataReader.prototype.getInt32 = function (littleEndian) {
        if (littleEndian === void 0) { littleEndian = false; }
        var value = this.data.getInt32(this.currentOffset, littleEndian);
        this.currentOffset += 4;
        return value;
    };
    /**
     * Reads the next byte as a 8-bit unsigned int. There is
     * no alignment constraint; multi-byte values may be fetched from any offset.
     */
    StreamedDataReader.prototype.getUint8 = function () {
        var value = this.data.getUint8(this.currentOffset);
        this.currentOffset++;
        return value;
    };
    /**
     * Reads the next 2 bytes as a 16-bit unsigned int. There is
     * no alignment constraint; multi-byte values may be fetched from any offset.
     */
    StreamedDataReader.prototype.getUint16 = function (littleEndian) {
        if (littleEndian === void 0) { littleEndian = false; }
        var value = this.data.getUint16(this.currentOffset, littleEndian);
        this.currentOffset += 2;
        return value;
    };
    /**
     * Reads the next 4 bytes as a 32-bit unsigned int. There is
     * no alignment constraint; multi-byte values may be fetched from any offset.
     */
    StreamedDataReader.prototype.getUint32 = function (littleEndian) {
        if (littleEndian === void 0) { littleEndian = false; }
        var value = this.data.getUint32(this.currentOffset, littleEndian);
        this.currentOffset += 4;
        return value;
    };
    /**
     * Reads the next 8 bytes as a 64-bit int. There is
     * no alignment constraint; multi-byte values may be fetched from any offset.
     */
    StreamedDataReader.prototype.getBigInt64 = function (littleEndian) {
        if (littleEndian === void 0) { littleEndian = false; }
        var value = this.data.getBigInt64(this.currentOffset, littleEndian);
        this.currentOffset += 8;
        return value;
    };
    /**
     * Reads the next 8 bytes as a 64-bit unsigned int. There is
     * no alignment constraint; multi-byte values may be fetched from any offset.
     */
    StreamedDataReader.prototype.getBigUint64 = function (littleEndian) {
        if (littleEndian === void 0) { littleEndian = false; }
        var value = this.data.getBigUint64(this.currentOffset, littleEndian);
        this.currentOffset += 8;
        return value;
    };
    /**
     * Returns a unicode character with the code from the next byte
     */
    StreamedDataReader.prototype.getChar = function () {
        return String.fromCodePoint(this.getUint8());
    };
    /**
     * Reads a string that has been encoded using a
     * modified UTF-8
     * format.
     */
    StreamedDataReader.prototype.getString = function () {
        var utflen = this.getUint16();
        var c = 0, c2 = 0, c3 = 0;
        var bytearr = new Uint8Array(this.buffer.slice(this.currentOffset, this.currentOffset + utflen));
        this.currentOffset += utflen;
        var start = 0;
        var end = utflen;
        var result = '';
        while (start < end) {
            c = bytearr[start];
            if (c > 127)
                break;
            start++;
            result += String.fromCodePoint(c);
        }
        while (start < end) {
            c = bytearr[start];
            switch (c >> 4) {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                    /* 0xxxxxxx*/
                    start++;
                    result += String.fromCodePoint(c);
                    break;
                case 12:
                case 13:
                    /* 110x xxxx   10xx xxxx*/
                    start += 2;
                    if (start > end)
                        throw new errors_1.StringParsingError('malformed input: partial character at end', result);
                    c2 = bytearr[start - 1];
                    if ((c2 & 0xc0) !== 0x80)
                        throw new errors_1.StringParsingError('malformed input around byte ' + start, result);
                    result += ((c & 0x1f) << 6) | (c2 & 0x3f);
                    break;
                case 14:
                    /* 1110 xxxx  10xx xxxx  10xx xxxx */
                    start += 3;
                    if (start > end)
                        throw new errors_1.StringParsingError('malformed input: partial character at end', result);
                    c2 = bytearr[start - 2];
                    c3 = bytearr[start - 1];
                    if ((c2 & 0xc0) !== 0x80 || (c3 & 0xc0) !== 0x80)
                        throw new errors_1.StringParsingError('malformed input around byte ' + (start - 1), result);
                    result += ((c & 0x0f) << 12) | ((c2 & 0x3f) << 6) | ((c3 & 0x3f) << 0);
                    break;
                default:
                    /* 10xx xxxx,  1111 xxxx */
                    throw new errors_1.StringParsingError('malformed input around byte ' + start, result);
            }
        }
        // The number of chars produced may be less than utflen
        return result;
    };
    /**
     * Reads the next byte as a boolean
     */
    StreamedDataReader.prototype.getBool = function () {
        var value = this.getInt8();
        if (value < 0)
            throw new Error('Bat byte input');
        return value !== 0;
    };
    return StreamedDataReader;
}());
exports.StreamedDataReader = StreamedDataReader;
//# sourceMappingURL=reader.js.map