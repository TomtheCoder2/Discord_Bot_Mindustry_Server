"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamedDataWriter = void 0;
var tslib_1 = require("tslib");
var StreamedDataWriter = /** @class */ (function () {
    function StreamedDataWriter(buffer) {
        this.buffer = buffer;
        /**
         * Internal byte offset of this `StreamedDataView`
         */
        this.currentOffset = 0;
        this.data = new DataView(buffer);
    }
    Object.defineProperty(StreamedDataWriter.prototype, "offset", {
        /**
         * The current byte offset of this `StreamedDataView`
         */
        get: function () {
            return this.currentOffset;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Writes a 32-bit float in the next 4 bytes. There is
     */
    StreamedDataWriter.prototype.setFloat32 = function (value, littleEndian) {
        if (littleEndian === void 0) { littleEndian = false; }
        this.data.setFloat32(this.currentOffset, value, littleEndian);
        this.currentOffset += 4;
    };
    /**
     * Writes a 64-bit float in the next 8 bytes.
     */
    StreamedDataWriter.prototype.setFloat64 = function (value, littleEndian) {
        if (littleEndian === void 0) { littleEndian = false; }
        this.data.setFloat64(this.currentOffset, value, littleEndian);
        this.currentOffset += 8;
    };
    /**
     * Writes a 8-bit int in the next byte.
     */
    StreamedDataWriter.prototype.setInt8 = function (value) {
        this.data.setInt8(this.currentOffset, value);
        this.currentOffset++;
    };
    /**
     * Writes a 16-bit int in the next 2 bytes.
     */
    StreamedDataWriter.prototype.setInt16 = function (value, littleEndian) {
        if (littleEndian === void 0) { littleEndian = false; }
        this.data.setInt16(this.currentOffset, value, littleEndian);
        this.currentOffset += 2;
    };
    /**
     * Writes a 32-bit int in the next 2 bytes.
     */
    StreamedDataWriter.prototype.setInt32 = function (value, littleEndian) {
        if (littleEndian === void 0) { littleEndian = false; }
        this.data.setInt32(this.currentOffset, value, littleEndian);
        this.currentOffset += 4;
    };
    /**
     * Writes a 8-bit unsigned int in the next byte.
     */
    StreamedDataWriter.prototype.setUint8 = function (value) {
        this.data.setUint8(this.currentOffset, value);
        this.currentOffset++;
    };
    /**
     * Writes a 16-bit unsigned int in the next 2 bytes.
     */
    StreamedDataWriter.prototype.setUint16 = function (value, littleEndian) {
        if (littleEndian === void 0) { littleEndian = false; }
        this.data.setUint16(this.currentOffset, value, littleEndian);
        this.currentOffset += 2;
    };
    /**
     * Writes a 32-bit unsigned int in the next 4 bytes.
     */
    StreamedDataWriter.prototype.setUint32 = function (value, littleEndian) {
        if (littleEndian === void 0) { littleEndian = false; }
        this.data.setUint32(this.currentOffset, value, littleEndian);
        this.currentOffset += 4;
    };
    /**
     * Writes a 64-bit bigint in the next 8 bytes.
     */
    StreamedDataWriter.prototype.setBigInt64 = function (value, littleEndian) {
        if (littleEndian === void 0) { littleEndian = false; }
        this.data.setBigInt64(this.currentOffset, value, littleEndian);
        this.currentOffset += 8;
    };
    /**
     * Writes a 64-bit bigint in the next 8 bytes.
     */
    StreamedDataWriter.prototype.setBigUint64 = function (value, littleEndian) {
        if (littleEndian === void 0) { littleEndian = false; }
        this.data.setBigUint64(this.currentOffset, value, littleEndian);
        this.currentOffset += 8;
    };
    /**
     * Returns a unicode character with the code from the next byte
     */
    StreamedDataWriter.prototype.setChar = function (value) {
        this.setUint8(value.codePointAt(0));
    };
    /**
     * Reads a string that has been encoded using a
     * modified UTF-8
     * format.
     */
    StreamedDataWriter.prototype.setString = function (str) {
        var e_1, _a;
        // code copied from DataOutputStream java implementation
        var strlen = str.length;
        var utflen = strlen; // optimized for ASCII
        for (var i_1 = 0; i_1 < strlen; i_1++) {
            var c = str.charCodeAt(i_1);
            if (c >= 0x80 || c === 0)
                utflen += c >= 0x800 ? 2 : 1;
        }
        if (utflen > 65535 || /* overflow */ utflen < strlen)
            throw new Error('the input string is too long');
        var bytearr = [];
        var count = 0;
        bytearr[count++] = (utflen >>> 8) & 0xff;
        bytearr[count++] = (utflen >>> 0) & 0xff;
        var i = 0;
        for (i = 0; i < strlen; i++) {
            // optimized for initial run of ASCII
            var c = str.charCodeAt(i);
            if (c >= 0x80 || c === 0)
                break;
            bytearr[count++] = c;
        }
        for (; i < strlen; i++) {
            var c = str.charCodeAt(i);
            if (c < 0x80 && c !== 0) {
                bytearr[count++] = c;
            }
            else if (c >= 0x800) {
                bytearr[count++] = 0xe0 | ((c >> 12) & 0x0f);
                bytearr[count++] = 0x80 | ((c >> 6) & 0x3f);
                bytearr[count++] = 0x80 | ((c >> 0) & 0x3f);
            }
            else {
                bytearr[count++] = 0xc0 | ((c >> 6) & 0x1f);
                bytearr[count++] = 0x80 | ((c >> 0) & 0x3f);
            }
        }
        try {
            for (var bytearr_1 = tslib_1.__values(bytearr), bytearr_1_1 = bytearr_1.next(); !bytearr_1_1.done; bytearr_1_1 = bytearr_1.next()) {
                var byte = bytearr_1_1.value;
                this.setUint8(byte);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (bytearr_1_1 && !bytearr_1_1.done && (_a = bytearr_1.return)) _a.call(bytearr_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return utflen + 2;
    };
    /**
     * Writes a boolean in the next byte
     */
    StreamedDataWriter.prototype.setBool = function (value) {
        this.setInt8(value ? 1 : 0);
    };
    return StreamedDataWriter;
}());
exports.StreamedDataWriter = StreamedDataWriter;
//# sourceMappingURL=writer.js.map