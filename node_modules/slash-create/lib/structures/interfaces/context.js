"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const user_1 = __importDefault(require("../user"));
const collection_1 = __importDefault(require("@discordjs/collection"));
const channel_1 = __importDefault(require("../channel"));
const role_1 = __importDefault(require("../role"));
const resolvedMember_1 = __importDefault(require("../resolvedMember"));
const messageInteraction_1 = __importDefault(require("./messageInteraction"));
/** Context representing a command interaction. */
class CommandContext extends messageInteraction_1.default {
    /**
     * @param creator The instantiating creator.
     * @param data The interaction data for the context.
     * @param respond The response function for the interaction.
     * @param webserverMode Whether the interaction was from a webserver.
     * @param deferEphemeral Whether the context should auto-defer ephemeral messages.
     */
    constructor(creator, data, respond, webserverMode, deferEphemeral = false) {
        super(creator, data, respond);
        /** The resolved users of the interaction. */
        this.users = new collection_1.default();
        /** The resolved members of the interaction. */
        this.members = new collection_1.default();
        /** The resolved roles of the interaction. */
        this.roles = new collection_1.default();
        /** The resolved channels of the interaction. */
        this.channels = new collection_1.default();
        /** @hidden */
        this._componentCallbacks = new Map();
        this.data = data;
        this.webserverMode = webserverMode;
        this.commandName = data.data.name;
        this.commandID = data.data.id;
        this.options = data.data.options ? CommandContext.convertOptions(data.data.options) : {};
        this.subcommands = data.data.options ? CommandContext.getSubcommandArray(data.data.options) : [];
        if (data.data.resolved) {
            if (data.data.resolved.users)
                Object.keys(data.data.resolved.users).forEach((id) => this.users.set(id, new user_1.default(data.data.resolved.users[id], this.creator)));
            if (data.data.resolved.members)
                Object.keys(data.data.resolved.members).forEach((id) => this.members.set(id, new resolvedMember_1.default(data.data.resolved.members[id], data.data.resolved.users[id], this.creator)));
            if (data.data.resolved.roles)
                Object.keys(data.data.resolved.roles).forEach((id) => this.roles.set(id, new role_1.default(data.data.resolved.roles[id])));
            if (data.data.resolved.channels)
                Object.keys(data.data.resolved.channels).forEach((id) => this.channels.set(id, new channel_1.default(data.data.resolved.channels[id])));
        }
        // Auto-defer if no response was given in 2 seconds
        this._timeout = setTimeout(() => this.defer(deferEphemeral || false), 2000);
    }
    /**
     * Registers a component callback from a custom ID.
     * This unregisters automatically when the context expires.
     * @param custom_id The custom ID of the component to register
     * @param callback The callback to use on interaction
     */
    registerComponent(custom_id, callback) {
        if (this.expired)
            throw new Error('This interaction has expired');
        if (!this.initiallyResponded || this.deferred)
            throw new Error('You must send a message before registering components');
        if (!this.messageID)
            throw new Error('Fetch your original message or use deferred messages before registering components');
        this._componentCallbacks.set(custom_id, callback);
        this.creator._awaitingCommandCtxs.set(this.messageID, this);
    }
    /**
     * Unregisters a component callback.
     * @param custom_id The custom ID of the component to unregister
     */
    unregisterComponent(custom_id) {
        return this._componentCallbacks.delete(custom_id);
    }
    /** @hidden */
    _onComponent(ctx) {
        if (this.messageID === ctx.message.id && this._componentCallbacks.has(ctx.customID))
            this._componentCallbacks.get(ctx.customID)(ctx);
    }
    /** @private */
    static convertOptions(options) {
        const convertedOptions = {};
        for (const option of options) {
            if ('options' in option)
                convertedOptions[option.name] = option.options ? CommandContext.convertOptions(option.options) : {};
            else
                convertedOptions[option.name] = 'value' in option && option.value !== undefined ? option.value : {};
        }
        return convertedOptions;
    }
    /** @private */
    static getSubcommandArray(options) {
        const result = [];
        for (const option of options) {
            if ('options' in option || !('value' in option))
                result.push(option.name, ...(option.options ? CommandContext.getSubcommandArray(option.options) : []));
        }
        return result;
    }
}
exports.default = CommandContext;
